print("1. Сделать отдельную функцию подсчета частоты символов текста. "
      "Назвать её соответствующим образом char_frequency,"
      " а дальше внутри программы обращаться к нашей функции и по названию сразу понять, "
      "что происходит в данной части программы.")

# объявили функцию для подсчета количества символов в тексте
def char_frequency():
    text = ("""
   У лукоморья дуб зелёный;
   Златая цепь на дубе том:
   И днём и ночью кот учёный
   Всё ходит по цепи кругом;
   Идёт направо -- песнь заводит,
   Налево -- сказку говорит.
   Там чудеса: там леший бродит,
   Русалка на ветвях сидит;
   Там на неведомых дорожках
   Следы невиданных зверей;
   Избушка там на курьих ножках
   Стоит без окон, без дверей;
   Там лес и дол видений полны;
   Там о заре прихлынут волны
   На брег песчаный и пустой,
   И тридцать витязей прекрасных
   Чредой из вод выходят ясных,
   И с ними дядька их морской;
   Там королевич мимоходом
   Пленяет грозного царя;
   Там в облаках перед народом
   Через леса, через моря
   Колдун несёт богатыря;
   В темнице там царевна тужит,
   А бурый волк ей верно служит;
   Там ступа с Бабою Ягой
   Идёт, бредёт сама собой,
   Там царь Кащей над златом чахнет;
   Там русский дух... там Русью пахнет!
   И там я был, и мёд я пил;
   У моря видел дуб зелёный;
   Под ним сидел, и кот учёный
   Свои мне сказки говорил.
   """)
    text = text.lower()
    text = text.replace(" ", "")
    text = text.replace("\n", "")

    count = {}  # для подсчета символов и их количества
    for char in text:
        if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
            count[char] += 1
        else:
            count[char] = 1

    for char, cnt in count.items():
        print(f"Символ {char} встречается {cnt} раз")
# вызвали функцию в любом месте программы
char_frequency()


print("2. Напишите функцию print_2_add_2, которая будет складывать 2 и 2, "
      "а затем печатать этот результат. Не забудьте вызвать функцию, чтобы увидеть результат.")

def print_2_add_2():
   result = 2 + 2
   print(result)

print_2_add_2()

print("3. Напишите функцию hello_world, которая будет печать приветственную строку 'Hello World' ")

def hello_world():
   print("Hello World")

hello_world()


print("4. Не очень хорошо, что наша функция char_frequency умеет работать только с одним текстом. "
      "Нужно срочно исправлять ситуацию и делать её универсальной. "
      "Тогда объявление функции будет выглядеть по-другому: ")

# объявили функцию для подсчета количества символов в неком абстрактном тексте
def char_frequency(text):
   text = text.lower()
   text = text.replace(" ", "")
   text = text.replace("\n", "")

   count = {}  # для подсчета символов и их количества
   for char in text:
       if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
           count[char] += 1
       else:
           count[char] = 1

   for char, cnt in count.items():
       print(f"Символ {char} встречается {cnt} раз")

text = """
   У лукоморья дуб зелёный;
   Златая цепь на дубе том:
   И днём и ночью кот учёный
   Всё ходит по цепи кругом;
   Идёт направо -- песнь заводит,
   Налево -- сказку говорит.
   Там чудеса: там леший бродит,
   Русалка на ветвях сидит;
   Там на неведомых дорожках
   Следы невиданных зверей;
   Избушка там на курьих ножках
   Стоит без окон, без дверей;
   Там лес и дол видений полны;
   Там о заре прихлынут волны
   На брег песчаный и пустой,
   И тридцать витязей прекрасных
   Чредой из вод выходят ясных,
   И с ними дядька их морской;
   Там королевич мимоходом
   Пленяет грозного царя;
   Там в облаках перед народом
   Через леса, через моря
   Колдун несёт богатыря;
   В темнице там царевна тужит,
   А бурый волк ей верно служит;
   Там ступа с Бабою Ягой
   Идёт, бредёт сама собой,
   Там царь Кащей над златом чахнет;
   Там русский дух... там Русью пахнет!
   И там я был, и мёд я пил;
   У моря видел дуб зелёный;
   Под ним сидел, и кот учёный
   Свои мне сказки говорил.
   """
char_frequency(text)

print("5. Давайте создадим функцию, которая будет возводить любое число в степень 2. ")

# функция, которая возводит любое число в квадрат
def pow_func(base):
   print(base ** 2)

pow_func(3)  # 9
pow_func(5)  # 25

print("6. Пусть наша функция теперь возводит число в любую степень, но по умолчанию возводит в степень 2."
      " Тогда её объявление будет выглядеть следующим образом: ")

# функция, которая возводит любое число в степень n
def pow_func( base,n = 9):
   print(base ** n)

pow_func(3)  # 9
pow_func(5, 3)  # 125

# В данном примере мы возводим число 3 в степень 2,
# которая указана по умолчанию. В данном случае мы не получаем ошибку,
# хотя указали всего один аргумент. Значение второго аргумента уже известно функции,
# поэтому если вы не укажете ей его, то она возьмет его по умолчанию.
# Но если вы захотите переопределить значение по умолчанию, то тоже не получите никакой ошибки.
# Как в случае возведения числа 5 в степень 3.

print("6. Напишите функцию, которая проверяет, является ли число n делителем числа a."
      " И выводит на экран соответствующее сообщение, является ли число делителем или нет. ")


def check_num(a, n):
   if a % n == 0:
       print(f"Число {n} является делителем числа {a}")
   else:
       print(f"Число {n} не является делителем числа {a}")

check_num(4, 2)  # Число 2 является делителем числа 4
check_num(5, 2)  # Число 2 не является делителем числа 5

print("7. Напишите функцию, которая печатает «обратную лесенку» следующего типа:"
      "n = 3 "
      "***"
      "**"
      "*"
      "n = 4"
      "****"
      "***"
      "**"
      "*")


def reverse_stair(n):
   for i in range(n, 0, -1):
       print("*" * i)

reverse_stair(3)

reverse_stair(4)

print("8. Сделаем так, чтобы наша функция возвращала результат вычисления:")


def pow_func(base, n=2):
    inside_result = base ** n
    return inside_result

print(pow_func(3))
# 9

print("9. Присвоить этот результат некоторой переменной и использовать это значение вне тела функции.")


def pow_func(base, n=2):
    inside_result = base ** n
    return inside_result

outside_result = pow_func(3)
print(outside_result)
# 9

print("10. Напишите функцию, которая будет возвращать количество делителей числа а. "
      "Пример ввода: 5 "
      "Пример вывода программы: 2")


def get_multipliers(a):
    count: int = 0
    for n in range(1, a + 1):
        if a % n == 0:
            count += 1

    return count


print(get_multipliers(5))  # 2
print(get_multipliers(4))  # 3


print("11. Напишите функцию, которая проверяет, является ли данная строка палиндромом или нет,"
      "и возвращает результат проверки. Пример: "
      "check_palindrome('test')  # False " \
      "check_palindrome('Кит на море не романтик')  # True")


def check_palindrome(str_):
   str_ = str_.lower()
   str_ = str_.replace(" ", "")

   if str_ == str_[::-1]:
       return True
   else:
       return False

print(check_palindrome("test")) # False
print(check_palindrome("Кит на море не романтик")) # True


print("12.Имена, определяемые внутри инструкции def, не вступают в конфликт с именами,"
      " находящимися за пределами инструкции def, даже если и там, "
      "и там присутствуют одинаковые имена переменных.")


def local():
   x = 5  # локальная переменная
   print(x)

x = 10
local()
print(x)

# 5
# 10

print("13.оператор global, который объявляет переменную доступной для блока кода, "
      "следующим за оператором. ")


x = 3


def func():
   global x # объявляем, что переменная является глобальной
   print(x)
   x = 5
   x += 5
   return x


func()
print(x)

print("14.Функция будет создавать функции, "
      "которые будут умножать на какое-то фиксированное число. ")


def get_mul_func(m):
   nonlocal_m = m

   def local_mul(n):
      return n * nonlocal_m

   return local_mul


two_mul = get_mul_func(2)  # возвращаем функцию, которая будет умножать числа на 2
print(two_mul(5))  # 5 * 2


print("15.Функция сумматор, которая будет складывать любое количество переданных ей аргументов.")


def adder(*nums):
   sum_ = 0
   for n in nums:
      sum_ += n

   return sum_


print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3
print(adder(1, 2, 3))  # 6


print("16.Функция, которая будет перемножать любое количество переданных ей аргументов.")


def mul(*nums):
   p = 1
   for n in nums:
      p *= n

   return p


print(mul())  # 1
print(mul(1))  # 1
print(mul(1, 2))  # 2
print(mul(1, 2, 3))  # 6


print("17.Если внутри функции нужно использовать списки, "
      "то этот момент можно обойти следующим образом:")


# установим аргумент name_arg пустым, а внутри функции будем проверять его
def correct_func(name_arg=None):
   if name_arg is None:
       name_arg = []
   print("Аргумент до изменения", name_arg)
   name_arg.append(1)
   print("Аргумент после изменения", name_arg)

# вызовем два раза одну и ту же функцию
correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])

print("18.Рекурсивная функция. Последовательность Фибоначчи начинается с 1 и 1, "
      "после чего каждое новое число является результатом сложения двух предыдущих чисел.")


def rec_fibb(n):
   if n == 1:
       return 1
   if n == 2:
      return 1
   return rec_fibb(n - 1) + rec_fibb(n - 2)

print(rec_fibb(10))  # 55


print("19. С помощью рекурсивной функции найдите сумму чисел от 1 до n.")


def rec_sum(n):
   if n == 1:  # терминальный случай
       return 1
   return n + rec_sum(n - 1)  # рекурсивный вызов

print(rec_sum(2)) #3

print("20.С помощью рекурсивной функции разверните строку.")


def reverse_str(string):
   if len(string) == 0:
       return ''
   else:
       return string[-1] + reverse_str(string[:-1])

print(reverse_str('test'))  # tset

print("21.Рекурсивная функция.Дано натуральное число N. Вычислите сумму его цифр. "
      "При решении этой задачи нельзя использовать строки, списки, массивы "
      "(ну и циклы, разумеется).")


def sum_digit(n):
   if n < 10:
       return n
   else:
       return n % 10 + sum_digit(n // 10)

print(sum_digit(123)) # 6


print("22. функция-генератор для чисел Фибоначчи будет выглядеть следующим образом:")


def fib():
   a, b = 0, 1
   yield a
   yield b

   while True:
       a, b = b, a + b
       yield b

for num in fib():
    print(num) #не запускать (будет бесконечная последовательность)

print("23. Создайте функцию-генератор, возвращающую бесконечную последовательность натуральных чисел. "
      "По умолчанию, она начинается с единицы и шагом 1, "
      "но пользователь может указать любой шаг и любое число в качестве аргумента функции,"
      " с которого будет начинаться последовательность.")


def count(start=1, step=1):
    counter = start
    while True:
        yield counter
        counter += step


for num in count(2, 4):
    print(num)  # не запускать (будет бесконечная последовательность)



print("24. Создайте генератор цикла, "
      "то есть в функцию на входе будет передаваться массив, "
      "например, [1, 2, 3], генератор будет вечно работать возвращая 1 2 3 1 2 3… и так далее.")


def repeat_list(list_):
   list_values = list_.copy()
   while True:
       value = list_values.pop(0)
       list_values.append(value)
       yield value

for i in repeat_list([1, 2, 3]):
   print(i) #не запускать (будет бесконечная последовательность)


print("25. возьмем строку и получим от неё итератор:")


# для примера возьмём строку
str_ = "my tst"
str_iter = iter(str_)

print(type(str_))  # строка
print(type(str_iter))  # итератор строки




print("26. с помощью функции next будем получать элементы, "
      "но не от самой строки, а от итератора строки:")


# для примера возьмём строку
str_ = "my tst"
str_iter = iter(str_)

print(type(str_))  # строка
print(type(str_iter))  # итератор строки

# Получим первый элемент строки
print(next(str_iter))  # m

# Получим ещё несколько элементов последовательности
print(next(str_iter))  # y
print(next(str_iter))  #
print(next(str_iter))  # t
print(next(str_iter))  # s
print(next(str_iter))  # t





